---
layout: post
title: Improving layout performance on Android
date: '2016-09-25T20:56:00.002+02:00'
author: Tomasz Cielecki
tags:
- Xamarin.Android
modified_time: '2016-09-25T21:03:19.963+02:00'
thumbnail: https://4.bp.blogspot.com/-_EN7IiGUmUw/V-eppFrEL8I/AAAAAAAADvQ/3BTb8aJASI47mAmEXAMCBRundVw_A8CagCLcB/s72-c/Screen%2BShot%2B2016-09-25%2Bat%2B12.38.13.png
blogger_id: tag:blogger.com,1999:blog-3433282516380174051.post-6356988876797173751
blogger_orig_url: http://blog.ostebaronen.dk/2016/09/improving-layout-performance-on-android.html
---

I've been working on improving performance of some of my Xamarin Android apps recently. One of the things I've been hunting down and improving on is <a href="https://developer.android.com/studio/profile/dev-options-overdraw.html">GPU overdraw</a>. What this means is how many times the same pixels on the screen are drawn per frame. Minimising this improves drawing performance on Android and in the end means smoother scrolling, faster drawing of views and generally makes your app perform more smoothly. The other thing is to hunt down nested layouts and flatten them to improve performance of the view laying itself out on the screen.<br /><br />Now there are actually quite a lot of things you can do to your app to improve on, to reduce GPU overdraw and how long it takes to layout your views. I will try to cover some of them in this blog post.<br /><br /><h2>Flattening your Layouts</h2><div>In order to improve how fast your views are laid out on the screen on the device, you can do a very important thing. <b>Flattening</b>&nbsp;your layout. What does this mean? Let me show you an example!</div><div><br /></div><div>Consider the following page layout, which is very much made out of nested <i>LinearLayout</i>s.<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://4.bp.blogspot.com/-_EN7IiGUmUw/V-eppFrEL8I/AAAAAAAADvQ/3BTb8aJASI47mAmEXAMCBRundVw_A8CagCLcB/s1600/Screen%2BShot%2B2016-09-25%2Bat%2B12.38.13.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="https://4.bp.blogspot.com/-_EN7IiGUmUw/V-eppFrEL8I/AAAAAAAADvQ/3BTb8aJASI47mAmEXAMCBRundVw_A8CagCLcB/s320/Screen%2BShot%2B2016-09-25%2Bat%2B12.38.13.png" width="194" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;"><br /></td></tr></tbody></table><br /></div><script src="https://gist.github.com/Cheesebaron/345a0e28030e92375e7a77e8e4028511.js?file=layout1.xml"></script> <br /><div>The problem with the nested layout above is the amount of measure passes which has to be done in order to lay it out. For each child with a <i>layout_weight</i>&nbsp;tag, it needs to measure itself twice. Other layouts need to measure themselves too. Imagine having a more complex layout, with a lot of nesting; would resolve in excessive measure passes and make displaying of your layout slow. Especially in cases where you use the layout is used as a row layout. This would hit the app performance quite a lot and there would be noticeable slowdowns in your app.<br />The layout above, can be flattened using <i>RelativeLayout</i>. You will notice, that <i>layout_weight</i>&nbsp;is quite powerful for layout out equal sized views, so some tricks have to be used to achieve the same with a <i>RelativeLayout</i>. The performance in the end is much better though.<br /><br /><script src="https://gist.github.com/Cheesebaron/345a0e28030e92375e7a77e8e4028511.js?file=layout2.xml"></script></div><br /><div>As you see. The above layout employs two additional layouts, which are used to center the other views. An alternative to <i>RelativeLayout</i>&nbsp;to make percentage sized views is <i><a href="https://developer.android.com/reference/android/support/percent/PercentRelativeLayout.html">PercentRelativeLayout</a>&nbsp;</i>from the <i>Android.Support.Percent</i>&nbsp;package. With it you can set aspect ratios, use percents for widths and heights and more. I would recommend keeping your layouts as simple as possible.<br /><br />If you simply wish to stack views on top of each other, you can use <i>FrameLayout</i>, which is a real good performer as well. <br /><br />You can read more about <a href="https://developer.android.com/training/improving-layouts/optimizing-layout.html">optimizing layouts in the official Android documentation</a>, which also shows how to use the Hierarchy viewer to inspect slow layouts.<br /><br /><h2>GPU Overdraw</h2><div>GPU overdraw is another problem you may encounter. What is this overdraw? It tells us about how many times the same pixel gets drawn on during a frame. Why is this bad? The more times the same pixels get drawn on, there more time we are wasting. In order to get fluid animations and scrolling etc. you need to have as high a frame rate as possible. A good goal is to try to hit 60 FPS (Frames Per Second) all the time. In order to do this, we need to spend as little as possible time drawing a frame and below 16ms. That is not a long time! Let's explore some things you can do as a developer to improve on this.</div><div><br /></div><h3>Enable showing GPU overdraw</h3><div>You can enable an overlay on your device or emulator, which will show you the GPU overdraw done by your app. You can find it in developer settings.<br /><br /><div class="separator" style="clear: both;"><a href="https://3.bp.blogspot.com/-IcvVCsRl0C8/V-fFarQUJfI/AAAAAAAADvg/vTgmZbZly7gwrKl6aIstap_WRRIptH-agCLcB/s1600/device-2016-09-25-143733.png" imageanchor="1" style="float: left; margin-bottom: 1em; margin-right: 1em;">        <img border="0" height="200" src="https://3.bp.blogspot.com/-IcvVCsRl0C8/V-fFarQUJfI/AAAAAAAADvg/vTgmZbZly7gwrKl6aIstap_WRRIptH-agCLcB/s200/device-2016-09-25-143733.png" width="111" />    </a>    <a href="https://4.bp.blogspot.com/-esAkskL0kmE/V-fFcEFbgaI/AAAAAAAADvk/2msEbH4lIiM_PFyeQYDdt3CIsCkeiJzuACLcB/s1600/device-2016-09-25-143809.png" imageanchor="1" style="float: left; margin-left: 1em; margin-right: 1em;">        <img border="0" height="200" src="https://4.bp.blogspot.com/-esAkskL0kmE/V-fFcEFbgaI/AAAAAAAADvk/2msEbH4lIiM_PFyeQYDdt3CIsCkeiJzuACLcB/s200/device-2016-09-25-143809.png" width="111" />    </a>    <a href="https://1.bp.blogspot.com/-XiC2FbYuEZg/V-fFc0U475I/AAAAAAAADvo/dyjxFW9sTFk2BwF5tqdxW6edrC1us1E2wCLcB/s1600/device-2016-09-25-143823.png" imageanchor="1" style="float: left; margin-bottom: 1em; margin-left: 1em;">        <img border="0" height="200" src="https://1.bp.blogspot.com/-XiC2FbYuEZg/V-fFc0U475I/AAAAAAAADvo/dyjxFW9sTFk2BwF5tqdxW6edrC1us1E2wCLcB/s200/device-2016-09-25-143823.png" width="111" />    </a></div><div style="clear: both;">&nbsp;This will give you a funny looking screen with colors laid on top of it. Now these colors actually mean something.</div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://developer.android.com/images/tools/performance/debug-gpu-overdraw/gettingstarted_image03.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="https://developer.android.com/images/tools/performance/debug-gpu-overdraw/gettingstarted_image03.png" width="281" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Overdraw chart from <a href="https://developer.android.com/studio/profile/dev-options-overdraw.html">Android Documentation</a></td></tr></tbody></table>The purple-ish blue means pixels have been over drawn once, green means twice, light red means thrice and dark red 4 times or more. You will also see stuff showing in its original color, this means that the pixels have not been overdrawn. The aim is to have no overdraw at all. However, this can be very hard to accomplish, unless you just have a background drawn on the screen.<br /><br /><h3>Removing backgrounds from views</h3>&nbsp;A simple thing to reduce overdraw is to just remove backgrounds from views. Let us consider the first layout I showed you, now with everything having a background.<br /><br /><script src="https://gist.github.com/Cheesebaron/345a0e28030e92375e7a77e8e4028511.js?file=layout3.xml"></script></div>This will gives us this when showing it with GPU overdraw debugging enabled.<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-uYoQKuj0v5k/V-fTnzFPQpI/AAAAAAAADwM/Wa7WEGZHizo37Cuy_OgXVYFwebfs9X9ZgCLcB/s1600/device-2016-09-25-153930.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://3.bp.blogspot.com/-uYoQKuj0v5k/V-fTnzFPQpI/AAAAAAAADwM/Wa7WEGZHizo37Cuy_OgXVYFwebfs9X9ZgCLcB/s320/device-2016-09-25-153930.png" width="180" /></a></div><div class="separator" style="clear: both; text-align: center;"></div><br /><div class="separator" style="clear: both; text-align: center;"></div></div><div>Our layout is <span style="color: red;"><b>RED</b></span> just because we added backgrounds to our layouts. Removing these backgrounds reduce overdraw significantly and in turn improves performance of your app.<br /><br />Just removing the outermost background reduces overdraw and in this layout the change won't be visible anyways.<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-SSIOJMAmwVI/V-fT47qtB9I/AAAAAAAADwQ/G1j7RxpebkYBe1K3Rg23d3Ce0YPXbXlTQCLcB/s1600/device-2016-09-25-154045.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://4.bp.blogspot.com/-SSIOJMAmwVI/V-fT47qtB9I/AAAAAAAADwQ/G1j7RxpebkYBe1K3Rg23d3Ce0YPXbXlTQCLcB/s320/device-2016-09-25-154045.png" width="180" /></a></div><div class="separator" style="clear: both; text-align: center;"></div>The two nested <i>LinearLayout</i>s use the same color, what if we use that as our theme background and remove the color from the layouts?<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-aUWrMbPFkAk/V-fUId2rAmI/AAAAAAAADwU/DdVng1LF4to6FONTRoIBFFpnCEMQDfsIQCLcB/s1600/device-2016-09-25-154142.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://1.bp.blogspot.com/-aUWrMbPFkAk/V-fUId2rAmI/AAAAAAAADwU/DdVng1LF4to6FONTRoIBFFpnCEMQDfsIQCLcB/s320/device-2016-09-25-154142.png" width="180" /></a></div>Again less overdraw. Here is the view without GPU overdraw enabled.</div><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-RB8Q2fPbBJc/V-fUZlkUQVI/AAAAAAAADwY/gAYVRAI7Ngg1qWpVFSHiOFxElYz9nvOagCLcB/s1600/device-2016-09-25-154241.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://3.bp.blogspot.com/-RB8Q2fPbBJc/V-fUZlkUQVI/AAAAAAAADwY/gAYVRAI7Ngg1qWpVFSHiOFxElYz9nvOagCLcB/s320/device-2016-09-25-154241.png" width="180" /></a></div><div>In this case, since the buttons themselves have a background, there will be some overdraw and that can we sometimes cannot do anything to prevent. However, simply reducing a layout from being red all over to green or light blue, means a lot towards performance. Especially in cases where the layout is used in a <i>ListView </i>or <i>RecyclerView </i>or similar Adapter type of view as less time is used to draw the row.<br /><br />Hence, try to avoid using backgrounds, especially if you can't see them at all. Also a good idea is instead of adding a background to each layout, add that background to your theme, which is pretty simple.</div><script src="https://gist.github.com/Cheesebaron/345a0e28030e92375e7a77e8e4028511.js?file=theme.xml"></script> <br /><div>You can also opt to actively remove backgrounds from views with <i>android:background:"@null"</i> for views you don't really care about their background.<br /><br />As for shadows, borders and the like, which you could do as a background. If you really have to have them use 9-patches with transparency in the areas you don't show anyways. Android will optimize the drawing of these for you and will not overdraw here.<br /><h3>Reducing overdraw in custom views</h3>You might have views that override the <i>OnDraw</i> method where you draw stuff to the <i>Canvas</i> it provides. Here overdraw matters as well. Using <i>OnDraw</i> is what normal views essentially end up using in the end when they draw them selves on the screen. So you have to be careful here as well.<br /><br />One way to eliminate all overdraw is to draw to a <i>Bitmap</i> first and then draw that to the canvas. This is normally know as <a href="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics">double buffering</a>. Be careful with using this, it gives the overhead of first drawing to the <i>Bitmap</i> then to the canvas which draws it to the screen.</div><br /><script src="https://gist.github.com/Cheesebaron/345a0e28030e92375e7a77e8e4028511.js?file=double1.cs"></script> <br /><div>The above code shows a simplified version of it. It does indeed result in just 1x overdraw if draw on a background. However, if your draw code is slow, you may encounter flickering if you need to redraw your view a lot. <br /><i>SurfaceView </i>in Android does it a bit differently. It does all the buffered drawing on a separate thread. You could do this as well. Then call <i>Invalidate()</i> or <i>PostInvalidate()</i> when you need the buffer to be shown on the screen<br /><br />The technique I ended up using is a modified version, where I delay the drawing until everything is drawn on the Bitmap. Then I signal with PostInvalidate(). It looks something like this the code below. </div><br /><script src="https://gist.github.com/Cheesebaron/345a0e28030e92375e7a77e8e4028511.js?file=double2.cs"></script> <br /><div>Now this could probably made a bit simpler. However, what I achieve with this is, whenever I manually signal with <i>Refresh()</i> I cancel any current drawing operations to the buffer as I am not interested in what it provides as it is old data... <i>PostInvalidate()</i> triggers the <i>OnDraw</i> method whenever the GPU is ready. In here I kick off a new <i>Task</i> which draws to the buffer. When that <i>Task</i> is done it calls <i>PostInvalidate()</i> to signal that the buffer has changed and that will be drawn. It is a variation of double buffering, which allows draw operations to take a long time. This has resulted in smooth scrolling of the RecyclerView I am using with these graphs as rows and no overdraw.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-rDuYqq7SyVE/V-gbQfPpKQI/AAAAAAAADww/JM3ZYgF-JFs8TyS5vwj1NTM4pD_fvY1kwCLcB/s1600/device-2016-09-23-132916.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://3.bp.blogspot.com/-rDuYqq7SyVE/V-gbQfPpKQI/AAAAAAAADww/JM3ZYgF-JFs8TyS5vwj1NTM4pD_fvY1kwCLcB/s320/device-2016-09-23-132916.png" width="180" /></a><a href="https://1.bp.blogspot.com/-BIYBh-2uuo8/V-gbRpezhfI/AAAAAAAADw0/Hwsu6BLYOXsZ7BHPClt45tUfpcCKHpX4ACLcB/s1600/device-2016-09-23-130956.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://1.bp.blogspot.com/-BIYBh-2uuo8/V-gbRpezhfI/AAAAAAAADw0/Hwsu6BLYOXsZ7BHPClt45tUfpcCKHpX4ACLcB/s320/device-2016-09-23-130956.png" width="180" /></a></div></div><div>Maybe you can use some of these techniques in your app. Let me know what you find out in your application. <br />In general you want to <br /><ul><li>Flatten your layouts to reduce measure calls</li><ul><li>Use RelativeLayout instead of LinearLayout with weights</li><li>Even better FrameLayout for stacked views </li></ul><li>Remove backgrounds that are not shown anyways</li><ul><li>Use theme background where applicable</li><li>android:background:"@null" </li></ul><li>Use 9-patch for borders and shadows</li><li>Reduce overdraw in your own OnDraw calls</li></ul><h4>Resources</h4><a href="https://medium.com/@elifbon/android-application-performance-step-1-rendering-ba820653ad3#.dsuai4bx6">https://medium.com/@elifbon/android-application-performance-step-1-rendering-ba820653ad3</a><br /><a href="https://www.hackerearth.com/practice/notes/rendering-performance-in-android-overdraw/">https://www.hackerearth.com/practice/notes/rendering-performance-in-android-overdraw/</a><br /><a href="http://www.xenomachina.com/2011/05/androids-2d-canvas-rendering-pipeline.html">http://www.xenomachina.com/2011/05/androids-2d-canvas-rendering-pipeline.html</a><br /><a href="http://developer.android.com/tools/performance/debug-gpu-overdraw/index.html">http://developer.android.com/tools/performance/debug-gpu-overdraw/index.html</a><br /><a class="markup--anchor markup--li-anchor" data-href="http://developer.android.com/reference/android/graphics/Canvas.html" href="http://developer.android.com/reference/android/graphics/Canvas.html" rel="nofollow">http://developer.android.com/reference/android/graphics/Canvas.html</a><br /><a href="https://www.udacity.com/course/android-performance--ud825">https://www.udacity.com/course/android-performance--ud825</a> <br /><br /><br /></div>